<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Recent Content on  </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://ms-iot.github.io/windows-on-fridges//index.xml</link>
    
    
    
    <updated>Mon, 01 Jul 2013 00:00:00 UTC</updated>
    
    <item>
      <title>Introduction</title>
      <link>http://ms-iot.github.io/windows-on-fridges/overview/introduction</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/overview/introduction</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;What is Windows on Fridges?&lt;/h2&gt;

&lt;p&gt;Windows on Fridges is an end-to-end solution that makes use of the &lt;a href=&#34;http://windowsondevices.com&#34;&gt;Microsoft
Developer Platform for IoT&lt;/a&gt; with an Intel Galileo
board, and &lt;a href=&#34;http://azure.microsoft.com&#34;&gt;Microsoft Azure&lt;/a&gt; web services.&lt;/p&gt;

&lt;p&gt;It is the intern project for the 2014 Explorer interns on the Internet of Things
Experiences Team. The original conception of this project was to create an autonomous robot that
would deliver drinks to your office.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;The End-to-end&lt;/h2&gt;

&lt;p&gt;The full end to end consists of multiple different pieces.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://github.com/ms-iot/wof-webapp&#34;&gt;Web application&lt;/a&gt; that allows users to input a room they want a drink delivered to.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://github.com/ms-iot/wof-webapp&#34;&gt;Pathfinding service&lt;/a&gt; that is hosted on azure.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://github.com/ms-iot/wof-nodebot-server&#34;&gt;REST server&lt;/a&gt; that interacts with the client.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://github.com/ms-iot/wof-nodebot-client&#34;&gt;Client application&lt;/a&gt; which interacts directly with the hardware.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://google.com&#34;&gt;Firmata&lt;/a&gt; the protocol running on the Galileo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All together this allows a user to input the room they want a drink delivered to.
The path is then calculated and converted to a list of instructions that are then
sent to the REST server. The REST server then sends the list to the client over
a websocket connection. The client uses a Firmata client library to communicate
with the hardware.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Next Steps&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/overview/quickstart&#34;&gt;Quick start&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://github.com/ms-iot/windows-on-fridges&#34;&gt;Star us on Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Press, Blogs and Media Coverage</title>
      <link>http://ms-iot.github.io/windows-on-fridges/community/press</link>
      <pubDate>Mon, 24 Mar 2014 20:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/community/press</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Press&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started</title>
      <link>http://ms-iot.github.io/windows-on-fridges/overview/quickstart</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/overview/quickstart</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Step 1. Get Hello Blinky running on your board.&lt;/h2&gt;

&lt;p&gt;Follow the instructions for &lt;a href=&#34;http://ms-iot.github.io/content/HelloBlinky.htm&#34;&gt;Hello Blinky&lt;/a&gt;.
This will ensure that you can create projects and deploy to your board.&lt;/p&gt;

&lt;p&gt;This tutorial will assume a general level of understanding of the Galileo
Development Platform for Windows.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Step 2. Install Project Dependencies&lt;/h2&gt;

&lt;p&gt;This project requires a few extra peices of software.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://git-scm.com/&#34;&gt;Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nodejs.org&#34;&gt;NodeJS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://python.org&#34;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Step 3. Setup Azure&lt;/h2&gt;

&lt;p&gt;This step is not required as everything can be hosted locally.&lt;/p&gt;

&lt;p&gt;At this point if you do want to use Azure, just create an account.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Future</title>
      <link>http://ms-iot.github.io/windows-on-fridges/meta/roadmap</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/meta/roadmap</guid>
      <description>&lt;p&gt;Some ideas to build on this project&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Contributing</title>
      <link>http://ms-iot.github.io/windows-on-fridges/community/contributing</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/community/contributing</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Contributing&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Contact</title>
      <link>http://ms-iot.github.io/windows-on-fridges/community/contact</link>
      <pubDate>Mon, 24 Mar 2014 20:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/community/contact</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Contact&lt;/h2&gt;

&lt;p&gt;Join us on Freenode at #windowsondevices&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hardware</title>
      <link>http://ms-iot.github.io/windows-on-fridges/nodebot/hardware</link>
      <pubDate>Tue, 01 Jul 2014 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/nodebot/hardware</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Hardware&lt;/h2&gt;

&lt;p&gt;The parts used are entirely dependent on what you wish to build.
This is the parts list for the robot that we built.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://windowsondevices.com&#34;&gt;Galileo Board&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://radioshack.com&#34;&gt;Motor Shield&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://makeblocks.cc&#34;&gt;Makeblock Robotics Kit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amazon.com&#34;&gt;Wireless Adapter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amazon.com&#34;&gt;Galileo Battery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amazon.com&#34;&gt;USB to Barrel Plug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amazon.com&#34;&gt;Motor Battery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amazon.com&#34;&gt;Deans connector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amazon.com&#34;&gt;Battery Charger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amazon.com&#34;&gt;USB Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://thinkgeek.com&#34;&gt;Micro Fridge&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Configuring</title>
      <link>http://ms-iot.github.io/windows-on-fridges/overview/configuration</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/overview/configuration</guid>
      <description>

&lt;p&gt;There is some small configuration to keep in mind as you use the different parts
of this project&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;Nodebot Server&lt;/h2&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Nodebot Client&lt;/h2&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Firmata&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>License</title>
      <link>http://ms-iot.github.io/windows-on-fridges/meta/license</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/meta/license</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;License&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Source Organization</title>
      <link>http://ms-iot.github.io/windows-on-fridges/overview/source-directory</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/overview/source-directory</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Source for the Project&lt;/h2&gt;

&lt;p&gt;Sources for our project are located in multiple different repositories.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Web App&lt;/li&gt;
&lt;li&gt;Nodebot Server&lt;/li&gt;
&lt;li&gt;Nodebot Client&lt;/li&gt;
&lt;li&gt;Documentation&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Azure</title>
      <link>http://ms-iot.github.io/windows-on-fridges/webservices/azure</link>
      <pubDate>Tue, 01 Jul 2014 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/webservices/azure</guid>
      <description></description>
    </item>
    
    <item>
      <title>Build</title>
      <link>http://ms-iot.github.io/windows-on-fridges/nodebot/building</link>
      <pubDate>Tue, 01 Jul 2014 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/nodebot/building</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Building the Robot&lt;/h2&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Step 1. Motors&lt;/h2&gt;

&lt;p&gt;Your Galileo should be plugged in and you should have &lt;a href=&#34;http://ms-iot.github.io/content/HelloBlinky.htm&#34;&gt;HelloBlinky&lt;/a&gt; working.
Connect the motor shield to the galileo and attach the 2 motors to the shield.
The motor shield we used is a &lt;a href=&#34;http://www.seeedstudio.com/depot/Motor-Shield-V20-p-1377.html?cPath=91_92&#34;&gt;SeeedStudio V2 Motor Shield&lt;/a&gt;. This shield can either be powered directly from the board or from an external power source via its external power jack. Without external power the motors may not turn when a load is applied.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Step 2. Robot frame&lt;/h2&gt;

&lt;p&gt;There are many frames to choose from when it comes to building a small to mid sized robot. &lt;a href=&#34;http://www.makeblock.cc/&#34;&gt;Makeblock&lt;/a&gt; is a simple open platform for robotics that is easy to put together. Here is an example configuration of a Makeblock robot with a galileo attached. You can get pretty creative here, there is no right way to build an awesome robot.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Step 3. Putting it all together&lt;/h2&gt;

&lt;p&gt;Secure all your parts on the robot frame. You will need space for a Galileo, 2 batteries, and a wifi adapter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Firmata</title>
      <link>http://ms-iot.github.io/windows-on-fridges/nodebot/firmata</link>
      <pubDate>Tue, 01 Jul 2014 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/nodebot/firmata</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Firmata&lt;/h2&gt;

&lt;p&gt;Firmata is a protocol that allows you to use a client library to interact with microcontrollers and other hardware. We will be using Standard Firmata on the Galileo and controlling it with &lt;a href=&#34;https://github.com/rwaldron/johnny-five&#34;&gt;Johnny-Five&lt;/a&gt; a NodeJS client library that is build for robotics.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web App</title>
      <link>http://ms-iot.github.io/windows-on-fridges/webservices/webapp</link>
      <pubDate>Tue, 01 Jul 2014 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/webservices/webapp</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Web App&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Node Client</title>
      <link>http://ms-iot.github.io/windows-on-fridges/nodebot/client</link>
      <pubDate>Tue, 01 Jul 2014 00:00:00 UTC</pubDate>
      
      <guid>http://ms-iot.github.io/windows-on-fridges/nodebot/client</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;Node Client&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Make sure you have &lt;a href=&#34;http://nodejs.org&#34;&gt;NodeJS&lt;/a&gt; and &lt;a href=&#34;http://python.org&#34;&gt;Python&lt;/a&gt; installed and in your path&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Johnny-Five is the client library we will be using to interact with Firmata on the Galileo. Johnny-Five requires &lt;a href=&#34;https://github.com/voodootikigod/node-serialport&#34;&gt;SerialPort&lt;/a&gt; which is built with Python.&lt;/p&gt;

&lt;p&gt;To get started clone the &lt;a href=&#34;https://github.com/ms-iot/wof-nodebot&#34;&gt;wof-nodebot-client&lt;/a&gt; repo.&lt;/p&gt;

&lt;p&gt;Open this directory in Command Line and type&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will install all the dependencies in the packages.json file.&lt;/p&gt;

&lt;p&gt;There is currently one change that need to be made before we can run this project&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node_modules &amp;gt; johnny-five &amp;gt; lib &amp;gt; board.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;comment out the line&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;message[color];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in the function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Board.prototype.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the client.js file change galileoIP to reflect either the hostname or IP Address of your board.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var galileoIP = &#39;mygalileo&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;later when we connect to the socket server you may want to change the serverUrl&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var serverUrl = &#39;http://localhost:1337&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should now be able to test the client, from the client source directory&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node client.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this should display a REPL prompt, at the prompt we can test the motors&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;motors.left.fwd(255)
motors.right.rev(255)
motors.left.stop()
motors.right.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point we should have a working robot that you can control from the command line.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Calibrating the Robot&lt;/h2&gt;

&lt;p&gt;The commands coming from Azure are in this format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{&amp;quot;Distance&amp;quot;:1,&amp;quot;Angle&amp;quot;:0},{&amp;quot;Distance&amp;quot;:1.4142135623730952,&amp;quot;Angle&amp;quot;:45},{&amp;quot;Distance&amp;quot;:1,&amp;quot;Angle&amp;quot;:-135},{&amp;quot;Distance&amp;quot;:1,&amp;quot;Angle&amp;quot;:180}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But the commands the robot understands are in this format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{&amp;quot;direction&amp;quot;:&#39;RIGHT&#39;,&amp;quot;speed&amp;quot;:255,&amp;quot;duration&amp;quot;:100},{&amp;quot;direction&amp;quot;:&#39;FORWARD&#39;,&amp;quot;speed&amp;quot;:255,&amp;quot;duration&amp;quot;:100},{&amp;quot;direction&amp;quot;:&#39;LEFT&#39;,&amp;quot;speed&amp;quot;:255,&amp;quot;duration&amp;quot;:100},{&amp;quot;direction&amp;quot;:&#39;FORWARD&#39;,&amp;quot;speed&amp;quot;:255,&amp;quot;duration&amp;quot;:100}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To translate between the two, we need to find out how long it takes the robot to turn a certain angle, and how long it takes to go forward a certain distance. The duration needed for each command can be easily calculated given the right, left, and forwards speeds. To make sure these speeds stay constant, we will have a set PWM at which they are measured. See below for instructions on how to measure the right and left rotational speeds, and the forward speed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var direction; 
var speed; 

if (command.Angle &amp;gt; 0) { 
    this.motorControl(&#39;RIGHT&#39;, setPWM, command.Angle / rotationalSpeedRight); 
    // deg/(deg/ms) = ms 
} else if (command.Angle &amp;lt; 0) { 

this.motorControl(&#39;LEFT&#39;, setPWM, command.Angle / rotationalSpeedLeft);  
// deg/(deg/ms) = ms 
} 

this.motorControl(&#39;FORWARD&#39;, setPWM, command.Distance / forwardSpeed);  
// distance/(distance/ms) = ms 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Calibration Variables&lt;/h3&gt;

&lt;p&gt;Every robot will be slightly different. To calibrate your robot to accurately follow your commands, follow the directions below.&lt;/p&gt;

&lt;p&gt;While measuring, keep in mind that your robot might move differently based on what surface (ex: carpet, tile, or wood flooring) it is moving on. Try to take your measurements on the surface the robot will be using most. If there are significant differences in robot performance on different surfaces you may want to keep the robot from going on certain surfaces that will throw it off by removing those paths from your map. The weight of the robot will also cause these numbers to shift. Do your measurements with a full can in the fridge.&lt;/p&gt;

&lt;h4 id=&#34;toc_3&#34;&gt;PWM&lt;/h4&gt;

&lt;p&gt;If we are going to measure a consistent speed of the robot, the motors need to have a consistent PWM. Choose one [0, 255] and stick with it. This must stay constant throughout your measurements and whenever your robot is following the angle, distance style of instructions or else your measured speeds will be meaningless.&lt;/p&gt;

&lt;h4 id=&#34;toc_4&#34;&gt;Rotational Speed Right&lt;/h4&gt;

&lt;p&gt;Rotational speed right can be calculated by sending the command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{direction: RIGHT, speed: setPWM, duration: 100} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then measure the degrees the robot turned. It may be helpful to mark the robot&amp;rsquo;s initial heading on the ground with tape to assist with measurements.&lt;/p&gt;

&lt;p&gt;Try with a few different durations to make sure the degrees/duration stays relatively consistent.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rotationalSpeedRight = average(degrees/duration)  // degrees/millisecond when turning right  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_5&#34;&gt;Rotational Speed Left&lt;/h4&gt;

&lt;p&gt;Rotational speed left can be similarly calculated with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{direction: LEFT, speed: setPWM, duration: 100} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It may turn out to be the same as rotationalSpeedRight, but you can&amp;rsquo;t assume that will be the case.&lt;/p&gt;

&lt;p&gt;Again, try with a few different durations to make sure the it is relatively consistent.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rotationalSpeedLeft = average(degrees/duration)  // degrees/millisecond when turning left 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_6&#34;&gt;Forward Speed&lt;/h4&gt;

&lt;p&gt;forwardSpeed is the distance your robot moves forward in one millisecond.&lt;/p&gt;

&lt;p&gt;The unit of distance you use should match the unit of distance of the map you use.&lt;/p&gt;

&lt;p&gt;For example, if your directions pass in the distance in meters, forwardSpeed should be calculated in meters/millisecond.&lt;/p&gt;

&lt;p&gt;Use&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{direction: FORWARD, speed: setPWM, duration: 100}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and measure how far your robot moves forward.&lt;/p&gt;

&lt;p&gt;Again, marking the ground could be helpful.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forwardSpeed = average(distance/millisecond)  // distance/millisecond when going forward 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>